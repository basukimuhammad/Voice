<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Voice Chat — Render-ready</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
:root{--bg:#071026;--card:#0b1220;--muted:#9aa6b2;--accent:#7dd3fc;--glass:rgba(255,255,255,0.03)}
*{box-sizing:border-box}
body{font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071126,#0b1220);color:#e6eef6;margin:0;padding:18px}
.app{max-width:1200px;margin:0 auto}
.header{display:flex;align-items:center;gap:12px;margin-bottom:14px}
.card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:14px;margin-bottom:12px;backdrop-filter: blur(6px)}
.row{display:flex;gap:12px}
.input{padding:10px;border-radius:10px;border:0;outline:none;background:rgba(255,255,255,0.02);color:inherit}
.btn{padding:10px 12px;border-radius:10px;border:0;background:var(--glass);cursor:pointer}
.small{font-size:13px;color:var(--muted)}
.users{min-width:260px}
#usersList{list-style:none;padding:0;margin:8px 0}
.user{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;transition:background .15s}
.user:hover{background:rgba(255,255,255,0.02)}
.dot{width:11px;height:11px;border-radius:50%}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.meter{width:80px;height:10px;background:rgba(255,255,255,0.04);border-radius:8px;overflow:hidden}
.meter > i{display:block;height:100%;width:0;background:linear-gradient(90deg,var(--accent),#38bdf8)}
.chat{height:300px;overflow:auto;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px}
.remote-audio{display:flex;flex-direction:column;gap:8px}
.file-btn{padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.03);cursor:pointer}
.footer{font-size:13px;color:var(--muted);text-align:center;margin-top:10px}
/* sidebar */
.layout{display:grid;grid-template-columns:1fr 360px;gap:12px}
.sidebar .card{height:540px;overflow:auto;padding:12px}
/* toast */
.toast{position:fixed;right:18px;bottom:18px;display:flex;flex-direction:column;gap:8px;z-index:9999}
.toast > div{background:rgba(0,0,0,0.6);padding:10px;border-radius:8px;}
/* expandable voice controls */
.voice-panel{display:flex;gap:8px;align-items:center}
.expandable{transition:max-height .25s ease;overflow:hidden;max-height:0}
.expanded{max-height:240px}
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <h2>Voice Chat (modern)</h2>
    <div class="small">Mesh P2P — Render ready (HTTPS required)</div>
  </div>

  <div class="card row">
    <div style="flex:1">
      <div style="display:flex;gap:8px;align-items:center">
        <input id="roomInput" class="input" placeholder="Nama room (contoh: room123)" />
        <input id="nameInput" class="input" placeholder="Nama kamu" />
        <button id="joinBtn" class="btn">Join Room</button>
        <button id="leaveBtn" class="btn" disabled>Leave</button>
      </div>
      <div class="small" style="margin-top:8px">Koneksi: <span id="status">idle</span></div>
    </div>

    <div class="users card sidebar" style="min-width:300px">
      <strong>Online pengguna</strong>
      <ul id="usersList"></ul>
    </div>
  </div>

  <div class="layout">
    <div>
      <div class="card controls">
        <button id="muteBtn" class="btn" disabled>Mute</button>
        <button id="expandBtn" class="btn" disabled>Voice Controls ▾</button>
        <button id="shareBtn" class="btn" disabled>Share Screen</button>

        <label class="file-btn">
          Pilih musik
          <input id="musicInput" type="file" accept="audio/*" style="display:none" />
        </label>
        <button id="playMusicBtn" class="btn" disabled>Play & Share Music</button>

        <label class="file-btn">
          Pilih file
          <input id="fileInput" type="file" style="display:none" />
        </label>
        <button id="sendFileBtn" class="btn" disabled>Send File</button>

        <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
          <div class="small">Your level</div>
          <div class="meter"><i id="localLevel"></i></div>
        </div>

        <div class="expandable" id="voicePanel">
          <div style="margin-top:12px" class="voice-panel">
            <div>
              <div class="small">Mic sensitivity</div>
              <input id="micGain" type="range" min="0" max="2" step="0.01" value="1" />
            </div>
            <div>
              <div class="small">Playback gain</div>
              <input id="playGain" type="range" min="0" max="2" step="0.01" value="1" />
            </div>
            <div>
              <div class="small">Push-to-talk</div>
              <button id="pttBtn" class="btn">Hold to talk</button>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <strong>Remote audio</strong>
        <div id="remoteContainer" class="remote-audio" style="margin-top:8px"></div>
      </div>
    </div>

    <div>
      <div class="card">
        <strong>Chat & Files</strong>
        <div class="chat" id="chatBox"></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <input id="chatInput" class="input" placeholder="Ketik pesan..." style="flex:1" />
          <button id="sendChatBtn" class="btn" disabled>Kirim</button>
        </div>
      </div>

      <div class="card small">
        <strong>Info</strong>
        <div id="infoBox">Tips: Untuk share screen gunakan desktop atau browser yang mendukung getDisplayMedia.</div>
      </div>
    </div>
  </div>

  <div class="footer">Dibuat untuk Render.com</div>
</div>

<div class="toast" id="toast"></div>

<script>
(async function(){
  const wsProtocol = (location.protocol === 'https:') ? 'wss:' : 'ws:';
  const wsUrl = wsProtocol + '//' + location.host;
  let ws;
  let localStream = null;
  const peers = {};
  let clientId = crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2);
  let roomName = '';
  let displayName = '';
  const servers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

  // DOM
  const joinBtn = document.getElementById('joinBtn');
  const leaveBtn = document.getElementById('leaveBtn');
  const roomInput = document.getElementById('roomInput');
  const nameInput = document.getElementById('nameInput');
  const statusEl = document.getElementById('status');
  const usersList = document.getElementById('usersList');
  const muteBtn = document.getElementById('muteBtn');
  const expandBtn = document.getElementById('expandBtn');
  const voicePanel = document.getElementById('voicePanel');
  const shareBtn = document.getElementById('shareBtn');
  const remoteContainer = document.getElementById('remoteContainer');
  const localLevel = document.getElementById('localLevel');
  const chatBox = document.getElementById('chatBox');
  const chatInput = document.getElementById('chatInput');
  const sendChatBtn = document.getElementById('sendChatBtn');
  const fileInput = document.getElementById('fileInput');
  const sendFileBtn = document.getElementById('sendFileBtn');
  const musicInput = document.getElementById('musicInput');
  const playMusicBtn = document.getElementById('playMusicBtn');
  const toastBox = document.getElementById('toast');
  const micGainEl = document.getElementById('micGain');
  const playGainEl = document.getElementById('playGain');
  const pttBtn = document.getElementById('pttBtn');

  function toast(msg) {
    const d = document.createElement('div'); d.textContent = msg; toastBox.appendChild(d);
    setTimeout(()=> { d.remove(); }, 6000);
  }

  function logChat(txt, who='system') {
    const d = document.createElement('div'); d.className='msg'; d.innerHTML = `<strong class="small">${who}:</strong> ${txt}`;
    chatBox.appendChild(d); chatBox.scrollTop = chatBox.scrollHeight;
  }

  function updateUsersList(list) {
    usersList.innerHTML = '';
    list.forEach(u => {
      const li = document.createElement('li'); li.className='user';
      const color = '#34d399';
      li.innerHTML = `<div style="width:36px;height:36px;border-radius:8px;background:linear-gradient(180deg,#0b1220,#0f1724);display:flex;align-items:center;justify-content:center">${(u.name||u.id).slice(0,2)}</div>
                      <div style="flex:1"><div style="font-weight:600">${u.name}</div><div class="small">${u.id}</div></div>
                      <div style="display:flex;flex-direction:column;align-items:flex-end"><div class="dot" style="background:${color}"></div></div>`;
      usersList.appendChild(li);
    });
  }

  function status(txt){ statusEl.textContent = txt; }

  function connectWS() {
    ws = new WebSocket(wsUrl);
    ws.onopen = () => status('connected');
    ws.onclose = () => { status('disconnected'); cleanupAllPeers(); toast('Disconnected from signaling'); };
    ws.onerror = (e) => console.error(e);
    ws.onmessage = async (ev) => {
      const msg = JSON.parse(ev.data);
      if (msg.type === 'existing-peers') {
        for (const id of msg.peers) await createPeerConnection(id, true);
      } else if (msg.type === 'new-peer') {
        await createPeerConnection(msg.id, true);
      } else if (msg.type === 'signal') {
        const from = msg.from; const payload = msg.payload;
        if (!peers[from]) await createPeerConnection(from, false);
        const pc = peers[from].pc;
        if (payload.sdp) {
          await pc.setRemoteDescription(payload.sdp);
          if (payload.sdp.type === 'offer') {
            const ans = await pc.createAnswer();
            await pc.setLocalDescription(ans);
            ws.send(JSON.stringify({ type:'signal', room:roomName, clientId, target:from, payload:{ sdp: pc.localDescription } }));
          }
        }
        if (payload.ice) {
          try { await pc.addIceCandidate(payload.ice); } catch(e){ console.warn('addIce failed',e); }
        }
      } else if (msg.type === 'peer-left') {
        const id = msg.id; removePeer(id); logChat(`${id} left`, 'system');
      } else if (msg.type === 'user-list') {
        updateUsersList(msg.users);
      } else if (msg.type === 'notify') {
        toast(msg.message);
      }
    };
  }

  async function createPeerConnection(peerId, isOffer) {
    if (peers[peerId]) return;
    const pc = new RTCPeerConnection(servers);
    peers[peerId] = { pc, name:null };

    // attach local tracks
    if (localStream) for (const track of localStream.getTracks()) {
      pc.addTrack(track, localStream);
    }

    // data channel
    let dc;
    if (isOffer) {
      dc = pc.createDataChannel('chat');
      setupDataChannel(peerId, dc);
    } else {
      pc.ondatachannel = (e) => { dc = e.channel; setupDataChannel(peerId, dc); };
    }

    pc.ontrack = (e) => {
      let container = peers[peerId].audioEl;
      if (!container) {
        container = document.createElement('div');
        const audio = document.createElement('audio'); audio.autoplay = true; audio.controls = true; audio.srcObject = e.streams[0];
        container.appendChild(audio);
        const meterWrap = document.createElement('div'); meterWrap.className='meter'; meterWrap.style.width='120px;margin-top:6px';
        const i = document.createElement('i'); meterWrap.appendChild(i);
        container.appendChild(meterWrap);
        remoteContainer.appendChild(container);
        peers[peerId].audioEl = container; peers[peerId].levelEl = i;

        try {
          const ctx = new AudioContext();
          const src = ctx.createMediaStreamSource(e.streams[0]);
          const analyser = ctx.createAnalyser(); analyser.fftSize = 2048; src.connect(analyser);
          peers[peerId].analyser = analyser; measureRemoteLevel(peerId);
        } catch(err){ console.warn('analyze failed', err); }
      }
    };

    pc.onicecandidate = (e) => {
      if (e.candidate) ws.send(JSON.stringify({ type:'signal', room:roomName, clientId, target:peerId, payload:{ ice: e.candidate } }));
    };

    pc.onconnectionstatechange = () => {
      if (pc.connectionState === 'connected') logChat(`Connected to ${peerId}`, 'system');
    };

    if (isOffer) {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      ws.send(JSON.stringify({ type:'signal', room:roomName, clientId, target:peerId, payload:{ sdp: pc.localDescription } }));
    }
  }

  function setupDataChannel(peerId, dc) {
    peers[peerId].dc = dc;
    dc.onopen = () => {
      logChat(`Data channel open with ${peerId}`, 'system');
      // send our display name meta
      dc.send(JSON.stringify({ type:'chat', text: `__meta_name:${displayName}` }));
    };
    dc.onmessage = (ev) => {
      if (typeof ev.data === 'string') {
        try {
          const json = JSON.parse(ev.data);
          if (json.type === 'chat') {
            const txt = json.text;
            if (txt.startsWith('__meta_name:')) {
              const nm = txt.split(':')[1]; peers[peerId].name = nm; logChat(`${nm} joined`, 'system');
            } else {
              logChat(txt, peers[peerId].name || peerId);
            }
          } else if (json.type === 'meta-file') {
            peers[peerId].incomingFile = { name: json.name, size: json.size, mime: json.mime, received:0, chunks:[] };
            logChat(`Incoming file ${json.name} from ${peers[peerId].name||peerId}`, 'system');
          }
        } catch(e){ console.log('json parse fail', e); }
      } else {
        const arr = new Uint8Array(ev.data);
        const f = peers[peerId].incomingFile;
        if (f) {
          f.chunks.push(arr); f.received += arr.byteLength;
          if (f.received >= f.size) {
            const blob = new Blob(f.chunks, { type: f.mime || 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = f.name; a.textContent = `Download ${f.name}`;
            const div = document.createElement('div'); div.appendChild(a); chatBox.appendChild(div); chatBox.scrollTop = chatBox.scrollHeight;
            logChat(`File ${f.name} received from ${peers[peerId].name||peerId}`, 'system'); peers[peerId].incomingFile = null;
          }
        }
      }
    };
  }

  let localAnalyser;
  function startLocalLevelMeter() {
    try {
      const ctx = new AudioContext();
      const src = ctx.createMediaStreamSource(localStream);
      localAnalyser = ctx.createAnalyser(); localAnalyser.fftSize = 2048; src.connect(localAnalyser);
      measureLocalLevel();
    } catch(e){ console.warn('local analyser fail', e); }
  }
  function measureLocalLevel() {
    if (!localAnalyser) return;
    const arr = new Uint8Array(localAnalyser.frequencyBinCount);
    localAnalyser.getByteFrequencyData(arr);
    const sum = arr.reduce((a,b)=>a+b,0);
    const avg = sum / arr.length / 255;
    localLevel.style.width = (avg*100) + '%';
    requestAnimationFrame(measureLocalLevel);
  }
  function measureRemoteLevel(peerId) {
    const p = peers[peerId]; if (!p || !p.analyser || !p.levelEl) return;
    const arr = new Uint8Array(p.analyser.frequencyBinCount); p.analyser.getByteFrequencyData(arr);
    const sum = arr.reduce((a,b)=>a+b,0); const avg = sum / arr.length / 255;
    p.levelEl.style.width = (avg*100) + '%'; requestAnimationFrame(()=>measureRemoteLevel(peerId));
  }

  function removePeer(id) {
    if (!peers[id]) return; try { peers[id].pc.close(); } catch(e){}
    if (peers[id].audioEl) peers[id].audioEl.remove(); delete peers[id];
  }
  function cleanupAllPeers() { Object.keys(peers).forEach(id=>removePeer(id)); }

  // UI actions
  joinBtn.onclick = async () => {
    if (!roomInput.value.trim()) return alert('Isi nama room dulu');
    roomName = roomInput.value.trim(); displayName = nameInput.value.trim() || 'Anon';
    clientId = crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2);
    connectWS();
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      startLocalLevelMeter();
      status('joined (waiting peers)');
      muteBtn.disabled = false; expandBtn.disabled = false; shareBtn.disabled = false; sendChatBtn.disabled = false; sendFileBtn.disabled = false; playMusicBtn.disabled = false; leaveBtn.disabled = false; joinBtn.disabled = true;
    } catch(e){ alert('Gagal akses mic: '+e.message); return; }

    ws.addEventListener('open', () => {
      ws.send(JSON.stringify({ type:'join', room:roomName, clientId, name: displayName }));
    });
  };

  leaveBtn.onclick = () => {
    if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type:'leave', room:roomName, clientId }));
    cleanupAllPeers(); if (localStream) localStream.getTracks().forEach(t=>t.stop()); localStream = null;
    if (ws) ws.close(); joinBtn.disabled=false; muteBtn.disabled=true; shareBtn.disabled=true; sendChatBtn.disabled=true; sendFileBtn.disabled=true; playMusicBtn.disabled=true; leaveBtn.disabled=true; status('left');
  };

  muteBtn.onclick = () => {
    if (!localStream) return; const enabled = localStream.getAudioTracks()[0].enabled; localStream.getAudioTracks()[0].enabled = !enabled; muteBtn.textContent = enabled ? 'Unmute' : 'Mute';
  };

  expandBtn.onclick = () => {
    voicePanel.classList.toggle('expanded');
  };

  shareBtn.onclick = async () => {
    if (!localStream) return;
    if (!navigator.mediaDevices.getDisplayMedia) return alert('Share screen tidak didukung oleh browser ini');
    try {
      const displayStream = await navigator.mediaDevices.getDisplayMedia({ video:true, audio:true });
      for (const id of Object.keys(peers)) {
        const pc = peers[id].pc; displayStream.getTracks().forEach(track => pc.addTrack(track, displayStream));
      }
      toast('Screen sharing aktif');
      displayStream.getTracks().forEach(t=>t.onended = () => toast('Screen sharing berhenti'));
    } catch(e){ alert('Gagal share screen: '+e.message); }
  };

  // Chat send
  sendChatBtn.onclick = () => {
    const txt = chatInput.value.trim(); if (!txt) return;
    Object.values(peers).forEach(p => { if (p.dc && p.dc.readyState === 'open') p.dc.send(JSON.stringify({ type:'chat', text: `${displayName}: ${txt}` })); });
    logChat(txt, 'you'); chatInput.value='';
  };

  // File send (chunked)
  let selectedFile = null; fileInput.onchange = (e)=> selectedFile = e.target.files[0];
  sendFileBtn.onclick = async () => {
    if (!selectedFile) return alert('Pilih file dulu');
    const targets = Object.keys(peers);
    for (const tid of targets) {
      const dc = peers[tid].dc; if (!dc || dc.readyState !== 'open') continue;
      dc.send(JSON.stringify({ type:'meta-file', name: selectedFile.name, size: selectedFile.size, mime: selectedFile.type }));
      const stream = selectedFile.stream(); const reader = stream.getReader();
      let done, value;
      while (true) { ({ done, value } = await reader.read()); if (done) break; dc.send(value); await new Promise(r=>setTimeout(r,5)); }
      logChat(`Sent file ${selectedFile.name} to ${tid}`, 'you');
    }
    fileInput.value=''; selectedFile=null;
  };

  // Music upload -> play locally & create MediaStream to share as track
  let musicEl = null; let musicDestination = null; let musicTrack = null;
  musicInput.onchange = (e) => {
    const f = e.target.files[0]; if (!f) return; if (musicEl) musicEl.remove();
    musicEl = new Audio(URL.createObjectURL(f)); musicEl.loop = false; musicEl.controls = true; musicEl.style.display='none'; document.body.appendChild(musicEl);
    playMusicBtn.disabled = false;
    musicEl.onended = () => toast('Music playback ended');
  };

  playMusicBtn.onclick = async () => {
    if (!musicEl) return alert('Pilih musik dulu');
    try {
      const audioCtx = new AudioContext();
      const src = audioCtx.createMediaElementSource(musicEl);
      musicDestination = audioCtx.createMediaStreamDestination();
      const gainNode = audioCtx.createGain(); gainNode.gain.value = parseFloat(playGainEl.value || 1);
      src.connect(gainNode); gainNode.connect(musicDestination); gainNode.connect(audioCtx.destination);
      musicTrack = musicDestination.stream.getAudioTracks()[0];
      for (const id of Object.keys(peers)) {
        const pc = peers[id].pc;
        const senders = pc.getSenders();
        const existing = senders.find(s=>s.track && s.track.kind === 'audio' && s.track.label === musicTrack.label);
        if (existing) { await existing.replaceTrack(musicTrack); } else { pc.addTrack(musicTrack, musicDestination.stream); }
      }
      musicEl.play(); toast('Playing & sharing music');
    } catch(e){ alert('Gagal play/share music: '+e.message); }
  };

  // push-to-talk
  pttBtn.onmousedown = () => { if (localStream) localStream.getAudioTracks()[0].enabled = true; pttBtn.textContent = 'Talking...'; };
  pttBtn.onmouseup = pttBtn.onmouseleave = () => { if (localStream) localStream.getAudioTracks()[0].enabled = false; pttBtn.textContent = 'Hold to talk'; };

  // small safety
  window.addEventListener('beforeunload', ()=> { if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type:'leave', room:roomName, clientId })); });

})();
</script>
</body>
</html>
